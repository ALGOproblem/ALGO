1. 병합 정렬, 퀵 정렬, 버블 정렬, 선택 정렬, 삽입 정렬 ... 
2. 퀵 정렬 : 평균적으로 NlogN으로 가장 빠르지만 최악의 경우에는 N^2. 추가적인 메모리 공간이 필요 없음. locality 지역성(부하가 좀 덜 걸림)
병합 정렬은 항상 NlogN이며 추가적인 메모리 공간이 필요하다. (Arrays.sort-> 퀵 정렬 구현. Collections.sort -> 병합 정렬 (별도의 힙 영역에 저장되기 떄문에)
3. 병합 정렬은 항상 NlogN인 이유
분할(Divide):
정렬할 데이터를 반으로 쪼개면서, 결국엔 크기가 1인 리스트(정렬된 상태)를 얻어요.
→ 이때 분할 과정은 리스트를 계속 반으로 나누기 때문에, 전체적으로 대략 log₂N 단계가 필요해요.
정복(Conquer):
나눠진 작은 리스트들을 다시 합치면서 정렬해요.
→ 두 개의 정렬된 리스트를 합치는 과정(merge)은 전체 원소 수 N에 비례하는 시간이 걸리므로 O(N)의 시간이 필요해요.
