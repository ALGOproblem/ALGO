# APS응용 Day12 동적계획법(Dynamic Programming)

## DP(동적계획법)

### 1. 정의

큰 문제를 작은 문제로 나누어 푼 뒤, 부분 문제의 결과를 저장하여 중복 계산을 피하는 알고리즘 설계 기법

### 2. 사용 조건

- 중복되는 부분 문제 (Overlapping Subproblems)
- 최적 부분 구조 (Optimal Substructure)

### 3. DP를 고려해야 하는 경우

- 하위 문제에서 중복 계산이 발생할 때
- **최적의 결과(최댓값/최솟값/경우의 수 등)** 를 구하는 문제일 때
- 탐색 속도를 줄이기 위해 **결과를 저장(Memoization)** 할 필요가 있을 때

### 4. 다른 알고리즘과 비교

| 알고리즘           | 사용 조건 / 특징                                            | 대표 문제                    | DP와 비교                                                           |
| ------------------ | ----------------------------------------------------------- | ---------------------------- | ------------------------------------------------------------------- |
| **브루트포스**     | 가능한 모든 경우를 탐색                                     | 부분집합, 순열/조합          | 중복 계산 많을 경우 비효율적 → DP로 최적화 가능                     |
| **그리디**         | 매 순간 최선의 선택이 전체 최적해로 이어짐 (탐욕 조건 만족) | 동전 교환(단순), 회의실 배정 | 모든 경우에 최적 해를 보장하지 않음 → 조건 만족 안 하면 DP 사용     |
| **분할 정복**      | 문제를 분할하고, 독립적으로 해결한 뒤 합침                  | 병합 정렬, 퀵 정렬           | 서브 문제 간 **중복이 없을 때** 적합 → 중복이 있다면 DP가 더 효율적 |
| **재귀**           | 간단한 로직, 깊은 트리 구조 탐색                            | DFS, 백트래킹                | 재귀가 중복 문제를 계속 탐색할 경우 → 메모이제이션 또는 DP로 최적화 |
| **탐색 (DFS/BFS)** | 그래프, 트리 순회                                           | 미로 탐색, 최단 경로         | 상태가 많고 중복 탐색이 있는 경우 → DP로 상태 저장하면서 탐색 가능  |
| **DP**             | 중복되는 부분 문제 + 최적 부분 구조                         | 피보나치, 배낭, LCS, LIS     | 최적화 문제에서 강력함, 성능 향상 가능                              |

---

## 문제 1: 1952번 수영장

### 문제

```
김 프로는 수영장을 이용한다.
김 프로는 지출이 너무 많아 내년 1년 동안 각 달의 이용 계획을 수립하고 가장 적은 비용으로 수영장을 이용할 수 있는 방법을 찾고 있다.
수영장에서 판매하고 있는 이용권은 아래와 같이 4 종류이다.

   ① 1일 이용권 : 1일 이용이 가능하다.
   ② 1달 이용권 : 1달 동안 이용이 가능하다. 1달 이용권은 매달 1일부터 시작한다.
   ③ 3달 이용권 : 연속된 3달 동안 이용이 가능하다. 3달 이용권은 매달 1일부터 시작한다.
    - 11월, 12월에도 3달 이용권을 사용할 수 있다.
    - 다음 해의 이용권만을 구매할 수 있기 때문에 3달 이용권은 11월, 12월, 1윌이나 12월, 1월, 2월 동안 사용하도록 구매할 수는 없다.
   ④ 1년 이용권 : 1년 동안 이용이 가능하다. 1년 이용권은 매년 1월 1일부터 시작한다.

이용 계획에 나타나는 숫자는 해당 달에 수영장을 이용할 날의 수를 의미한다.
각 이용권의 요금과 각 달의 이용 계획이 입력으로 주어질 때, 가장 적은 비용으로 수영장을 이용할 수 있는 방법을 찾고 그 비용을 정답으로 출력하는 프로그램을 작성하라.
```

### 접근

1. 여러개의 선택지, 순서대로 흘러가는 시간, 최저 비용 -> DP
2. 순서대로 흘러가는 시간에 대하여 이용권을 선택 -> 기존 값과 비교 -> 작은 값을 저장

### 문제 풀이

1. 일일 이용권 값 대입
2. 1달, 3달, 1년 이용권 비교

```java
for (int i = 1; i < 13; i++) {
    // 1일 이용권
    dp[i] = dp[i - 1] + months[i] * price[0];

    // 1달 이용권
    dp[i] = Math.min(dp[i], dp[i - 1] + price[1]);

    // 3달 이용권
    if (i >= 3)
        dp[i] = Math.min(dp[i], dp[i - 3] + price[2]);
    else
        dp[i] = Math.min(dp[i], price[2]); // 1, 2월에도 3달권 사용

    // 1년 이용권
    dp[12] = Math.min(dp[12], price[3]);

} // dp
```

---

## 문제 2 : 1970번 쉬운 거스름돈

### 문제

```
우리나라 화폐 ‘원’은 금액이 높은 돈을 우선적으로 계산할 때 돈의 개수가 가장 최소가 된다.
S마켓에서 사용하는 돈의 종류는 다음과 같다.
50,000 원/ 10,000 원 / 5,000 원 / 1,000 원 / 500 원 / 100 원 / 50 원 / 10 원

S마켓에서 손님에게 거슬러 주어야 할 금액 N이 입력되면 돈의 최소 개수로 거슬러 주기 위하여 각 종류의 돈이 몇 개씩 필요한지 출력하라.

[제약 사항]
1. N은 10이상 1,000,000이하의 정수이다. (10 ≤ N ≤ 1,000,000)
2. N의 마지막 자릿수는 항상 0이다. (ex : 32850)
```

### 접근

1. 메모리를 위해 최댓값을 100,000이라 생각하면서 `N / 10`을 입력값으로 사용한다.
2. coin(화폐)을 무한정 사용할 수 있다.
3. 행을 coin이라 생각하고 열에 금액을 배정
4. 열의 해당 금액(c)까지 내기 위해 가장 적은 최소 화폐 개수를 저장(최솟값)
5. 화폐당 몇 개를 사용했는지 출력해야 함<br>
   = 해당 금액에 대하여 가장 마지막에 사용한 화폐를 저장한다.
   - 이때 17500원의 가장 마지막에 사용한 화폐가 10000원일떄
   - 7500원(17500 - 10000)의 가장 마지막 사용한 화폐를 추적한다.
   - 그렇게 될때 가장 마지막에 사용한 화폐의 종류만 count 해준다.

- 그리디 알고리즘으로도 만족

### 풀이

1. dp: 화폐 개수 계산

```java
for (int i = 1; i <= MAX; i++) {
    int minCnt = MAX + 1; // 동전의 개수

    for (int j = 0; j < coins.length; j++) {
        int coin = coins[j];

        if (i >= coin && minCnt > dp[i - coin] + 1) {
            minCnt = dp[i - coin] + 1;
            used[i] = j; // 가장 최근에 사용한 동전의 인덱스(갱신될수록 커진다)
        }
    }

    dp[i] = minCnt;
}// dp
```

2. 사용한 화폐 개수 계산

```java
int[] count = new int[coins.length];
int temp = N;

while (temp > 0) {
    int coinIdx = used[temp];
    count[coinIdx]++;
    temp -= coins[coinIdx];
}
```

---

## 문제 3 : 3282번 0/1 Knapsack

### 문제

```
민수에게는 1번부터 N번까지의 번호가 부여된 N(1≤N≤100)개의 물건과 최대 K(1≤K≤1000) 부피만큼을 넣을 수 있는 가방이 있다.
1번 물건부터 N번 물건 각각은 부피  Vi와 가치 Ci 를 가지고 있다. (1≤Vi, Ci≤100)
민수는 물건들 중 몇 개를 선택하여 가방에 넣어서 그 가치의 합을 최대화하려고 한다.
단, 선택한 물건들의 부피 합이 K 이하여야 한다.
민수가 가방에 담을 수 있는 최대 가치를 계산하자.
```

### 접근

1. 가방에 넣을 물건은 오직 1개 밖에 없다.
2. 물건 1개에 대하여 선택/선택하지 않음으로 고려한다.

### 풀이

```java
for (int i = 1; i <= N; i++) {
    for (int j = 1; j <= K; j++) {
        if (j >= vol[i]) {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - vol[i]] + value[i]);
        } else {
            dp[i][j] = dp[i - 1][j];
        }
    }
}
```

---

## 문제 4 : 5215번 햄버거 다이어트

### 문제

```
평소 햄버거를 좋아하던 민기는 최근 부쩍 늘어난 살 때문에 걱정이 많다.
그렇다고 햄버거를 포기할 수 없었던 민기는 햄버거의 맛은 최대한 유지하면서 정해진 칼로리를 넘지 않는 햄버거를 주문하여 먹으려고 한다.
민기가 주로 이용하는 햄버거 가게에서는 고객이 원하는 조합으로 햄버거를 만들어서 준다.
하지만 재료는 미리 만들어서 준비해놓기 때문에 조합에 들어가는 재료를 잘라서 조합해주지는 않고, 재료를 선택하면 준비해놓은 재료를 그대로 사용하여 조합해준다.
민기는 이 가게에서 자신이 먹었던 햄버거의 재료에 대한 맛을 자신의 오랜 경험을 통해 점수를 매겨놓았다.
민기의 햄버거 재료에 대한 점수와 가게에서 제공하는 재료에 대한 칼로리가 주어졌을 때,
정해진 칼로리 이하의 조합 중에서 민기가 가장 선호하는 햄버거를 조합해주는 프로그램을 만들어보자.
(단 여러 재료를 조합하였을 햄버거의 선호도는 조합된 재료들의 맛에 대한 점수의 합으로 결정되고,
같은 재료를 여러 번 사용할 수 없으며, 햄버거의 조합의 제한은 칼로리를 제외하고는 없다.)

[입력]
첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 재료의 수, 제한 칼로리를 나타내는 N, L(1 ≤ N ≤ 20, 1 ≤ L ≤ 104)가 공백으로 구분되어 주어진다.
다음 N개의 줄에는 재료에 대한 민기의 맛에 대한 점수와 칼로리를 나타내는 Ti, Ki(1 ≤ Ti ≤ 103, 1 ≤ Ki ≤ 103)가 공백으로 구분되어 주어진다.

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 주어진 제한 칼로리 이하의 조합중에서 가장 맛에 대한 점수가 높은 햄버거의 점수를 출력한다.
```

### 접근

- 햄버거 조합 중 1개만 선택/선택하지 않음, 제한 칼로리 내에서의 최대 점수 -> DP

### 풀이

1. `N + 1` 크기의 점수, 칼로리(weight로 정의)를 저장

```java
int[] score = new int[N + 1];
int[] weight = new int[N + 1];
for (int i = 1; i <= N; i++) {
    score[i] = sc.nextInt();
    weight[i] = sc.nextInt();
}// 재료 정보 입력(점수, 칼로리)
```

2. 행: 재료의 종류, 열: 칼로리(1 ~ L)

```java
int[][] dp = new int[N + 1][L + 1];

for (int i = 1; i <= N; i++) { // 행: 음식
    for (int j = 1; j <= L; j++) { // 열 : 칼로리
        if (j >= weight[i]) {
            // 선택 하지 않음과 선택함을 비교한다
            dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + score[i]);

        } else {
            // 해당 칼로리보다 음식 칼로리가 더 클 때 -> 아예 입력 불가
            dp[i][j] = dp[i - 1][j];
        }
    }
}
```

---

## 문제 5 : 9296번 피보나치 수열

### 문제

```
피보나치 함수를 구현하여 5개의 입력값을 받고 그에 해당하는 피보나치 수를 구하시오.
즉, n번째 피보나치 수를 구하시오.
```

### 접근

- 기존의 값을 저장: 재귀 + 메모이징(Top-down)
- 그러나 위 방법은 메모리가 많이 필요

#### DP 방식의 장점

1. 필요한 크기를 정해서 메모리를 할당해 예측 가능함
2. 반복문이 재귀보다 빠름
3. 재귀(콜 스택)로 인한 스택 오버플로우를 방지함
4. Bottom-up(상향식)으로 직관적이다.
   - 가장 작은 문제부터 차례로 반복문으로 쌓아가는 방식

### 문제 풀이

- DP 사용

```java
static void dp(int max) {
    memo = new int[max + 1];
    memo[0] = 0;
    memo[1] = 1;

    for (int i = 2; i <= max; i++) {
        memo[i] = memo[i - 1] + memo[i - 2];
    }
}
```
