# 📝 백준 알고리즘 문제 풀이 정리

## 🌳 문제 14510 - 나무 높이
### 📌 해결 방법
1. **x일 만큼의 날짜를 설정**하고, **1의 날과 2의 날을 계산**한다.
2. 최대한 **2일을 먼저 사용하고**, 그 다음에 **1일을 사용**하는 방식으로 마무리한다.

---

## 🚀 문제 1446 - 지름길
### ❌ 처음에 잘못 생각한 부분
- **배열 방식**으로 문제를 풀고 싶어서 `arr[i] = i` 로 초기화 후, 
  지름길 입력을 받아서 **1~3까지 거리가 2라면 3부터 이후 D까지의 모든 거리를 업데이트**하는 방식 사용.
- 하지만 **지름길이 거리 순서대로 정렬되어 있지 않다면, 정확히 반영되지 않는 문제 발생.**

### ✅ 다시 생각한 해결 방법
1. **지름길 정보를 `shortcuts[]` 배열에 저장**
2. **0부터 시작해 모든 지점에서 지름길이 있는지 확인 후 업데이트**
   - 한 칸씩 이동하면서 모든 경우의 수를 고려
   ```java
   for (int i = 0; i <= D; i++) {
       if (i > 0) {
           arr[i] = Math.min(arr[i], arr[i - 1] + 1);
       }
       for (int[] shortcut : shortcuts) {
           int start = shortcut[0];
           int end = shortcut[1];
           int distance = shortcut[2];
           
           if (start == i && end <= D) {
               arr[end] = Math.min(arr[end], arr[start] + distance);
           }
       }
   }
   ```
3. **이 방식으로 한 칸씩 이동하면서, 최적의 경로를 지속적으로 업데이트하여 정확한 최단 거리 계산 가능!**



#### ✨ 주의할 점
- **배열을 사용한 접근법**에서 **지름길이 정렬되지 않으면 오류가 발생할 수 있음**을 확인.
- **한 칸씩 이동하면서 최적 경로를 갱신하는 방식**이 정확한 해결 방법임.
- **배열을 `Integer.MAX_VALUE` 로 초기화 후, 매 순간 최적의 값을 유지하는 방식이 중요!**



-------
## 문제 14284 📝 간선 이어가기 2

### 풀이 방식을 arr로 하려다가 너무 복잡해서 GPT의 도움을 받음

1. **입력 처리**  
   - `n`개의 정점과 `m`개의 간선을 입력받아 그래프를 **인접 리스트**로 저장한다.
2. **다익스트라 알고리즘 적용**  
   - 우선순위 큐(`PriorityQueue`)를 사용해 **가중치가 작은 간선부터 탐색**하며 최단 경로를 찾는다.
   - `s`에서 출발하여 `t`까지의 최소 비용을 계산한다.
3. **탐색 과정**  
   - 가장 작은 가중치를 가진 노드를 먼저 방문.
   - **더 짧은 거리 발견 시 갱신**하고 다시 큐에 추가.
   - `t`에 도달하는 순간 최소 가중치 합을 출력.

