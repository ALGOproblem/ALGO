# 📝 백준 알고리즘 문제 week3 풀이 정리

## 백준20057마법사상어와토네이도 🦈🦈
### 틀린 이유
1. 소수점 아래는 버린다라는 조건을 간과함
   각 비율에 대해 계산할 때 소수점 이하를 버리기 때문에,실제 각 칸으로 분산된 모래의 총합(movedSand)은 전체 모래의 정확히 45%가 아닐 수도 있으나
   그냥 전체 sand * 0.55해버림
2. int[] windx 배열과 int[] windy 배열을 실수로 잘못 계산함
   편하게 생각하면 배열을 90도회전, 180도회전, 270도회전과 다름 없는데 괜히 좌표값을 회전시킨다고 해서 헷갈림..

### 알고리즘
1. 달팽이순회 구하기
  원래는 visisted[] 배열로 if(범위벗어남 || visited) 이면 방향 바꾸는 것 선호 but 이 문제는 그렇게 못 품
```
while(num < N*N)
    for (int d = 0; d<2; d++)
       for (int i = 0; i<index; i++)
          if (범위 조건 확인)
              if (옮길 모래 없음) continue;
              spreadWind(x, y, direction) // 현재 위치, 방향 모두 전달
       direction = (direction + 1)%4 // 인덱스만큼 자리를 옮겼다면 방향 바꿔주기
    index++; // 두번의 방향만큼 진행했다면 인덱스 하나 늘리기
```


2. 모래날리기
  원래는 배열 자체를 90도, 180도, 270도 회전하려고 함. but timeout 우려
  이 문제에서 주의할 것은 "소수점 아래는 버림" 그리고 나머지는 전부 a 자리에 옮기기였음
  좌, 하, 우, 상 모든 배열에서 ratio, windx, windy 배열 계산 (a)자리는 어차피 나머지를 전부 계산한 다음에 빼서 옮기는 것이니 fail
```
for (int i = 0; i<9; i++){ // a를 제외한 나머지 모래 퍼지는 것(=movedSand) 계산'
  curSand = totalSand * ratio[i];
  nx, ny가 arr 배열 안에 들어온다 -> 해당 배열에 +=
  else : 밖으로 넘치는 모래(answer) +=
}
// sand - movedSand를 a 자리에 옮기기
만약 a자리도 범위 밖이라면 answer에 더하기

```
