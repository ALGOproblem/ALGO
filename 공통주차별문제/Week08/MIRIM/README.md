# Week 08

## [백준 14503번 로봇 청소기](https://www.acmicpc.net/problem/14503)

### 접근
- 구현 문제라고 생각함.
- 방향과 map에 대해 조건문을 분기로 행동이 달라지는 구현
- 문제 이해 + 접근: 6분, 문제 풀이: 20 ~ 30분 소요

### 잘못된 풀이
- 처음에 dfs처럼 재귀를 사용하려다 다시 돌아올 필요가 없다는 걸 깨닫고 Stack을 사용함
- 2번 테스트 케이스가 처음에 답이 나오지 않았음. 이유는 후진 시에 방향을 전환하는게 아니라 유지한다는 걸 놓쳤기 때문이다. 후진은 후진이다. 주의하자.

---

## [백준 17069번 파이프 옮기기2](https://www.acmicpc.net/problem/17069)

### 주의
**값이 long인데 int 배열로 하니까 당연히 답이 안나오지!!!!**   
거기다 dp 저장 시 방향 고려를 안했다.   
정리하자면   
1. int[][] dp로 선언해 방향에 따른 파이프 상태를 고려하지 않음
2. int로 선언해서 N이 클 때 오버플로우 나서 답을 구할 수 없음(당연하지...)

   
### 접근
1. 지난 주차 백준 1520번 내리막길 문제와 같은 로직이라는 게 떠오름
2. 그러나 dp인 것과 도착지 = 1, 도착지 -> 시작점으로 거슬러 올라오는 형태만 기억남고, 풀이는 머릿속에서 사라짐.
3. 지난 문제를 참고하면서 같은 로직인 부분과 다른 조건을 체크함.

### 풀이
#### 1. dp 선언

지난 번과 같이 -1 값을 갖는 dp를 선언   
여기서 int형을 선언하는 실수를 범함

``` java
dp = new long[N][N][3];
for (long[][] arr1 : dp) {
    for (long[] arr2 : arr1) {
        Arrays.fill(arr2, -1);
    }
}
```

#### 2. 시작점

(0, 1)에서 출발한다고 생각   
방향은 가로방향으로 0으로 설정

```java
System.out.println(dfs(0, 1, 0));
```

#### 3. Top-down 방식

해당 방식이 Top-down 방식 + dfs 방식의 핵심

```java
// 방문 체크
if (dp[r][c][dir] != -1) return dp[r][c][dir];

// 계산위해 초기화
dp[r][c][dir] = 0;
```

```java
dp[r][c][dir] += dfs(nr, nc, d); // 경로 누적
```
   
<br>

> 이상 까먹을 때쯤 매번 long형한테 당하는 리뷰였음...

---