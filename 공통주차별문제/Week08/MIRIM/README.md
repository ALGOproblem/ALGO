# Week 08

## [백준 14503번 로봇 청소기](https://www.acmicpc.net/problem/14503)

### 접근
- 구현 문제라고 생각함.
- 방향과 map에 대해 조건문을 분기로 행동이 달라지는 구현
- 문제 이해 + 접근: 6분, 문제 풀이: 20 ~ 30분 소요

### 잘못된 풀이
- 처음에 dfs처럼 재귀를 사용하려다 다시 돌아올 필요가 없다는 걸 깨닫고 Stack을 사용함
- 2번 테스트 케이스가 처음에 답이 나오지 않았음. 이유는 후진 시에 방향을 전환하는게 아니라 유지한다는 걸 놓쳤기 때문이다. 후진은 후진이다. 주의하자.

---

## [백준 17069번 파이프 옮기기2](https://www.acmicpc.net/problem/17069)

### 주의
**값이 long인데 int 배열로 하니까 당연히 답이 안나오지!!!!**   
거기다 dp 저장 시 방향 고려를 안했다.   
정리하자면   
1. int[][] dp로 선언해 방향에 따른 파이프 상태를 고려하지 않음
2. int로 선언해서 N이 클 때 오버플로우 나서 답을 구할 수 없음(당연하지...)

   
### 접근
1. 지난 주차 백준 1520번 내리막길 문제와 같은 로직이라는 게 떠오름
2. 그러나 dp인 것과 도착지 = 1, 도착지 -> 시작점으로 거슬러 올라오는 형태만 기억남고, 풀이는 머릿속에서 사라짐.
3. 지난 문제를 참고하면서 같은 로직인 부분과 다른 조건을 체크함.

### 풀이
#### 1. dp 선언

지난 번과 같이 -1 값을 갖는 dp를 선언   
여기서 int형을 선언하는 실수를 범함

``` java
dp = new long[N][N][3];
for (long[][] arr1 : dp) {
    for (long[] arr2 : arr1) {
        Arrays.fill(arr2, -1);
    }
}
```

#### 2. 시작점

(0, 1)에서 출발한다고 생각   
방향은 가로방향으로 0으로 설정

```java
System.out.println(dfs(0, 1, 0));
```

#### 3. Top-down 방식

해당 방식이 Top-down 방식 + dfs 방식의 핵심

```java
// 방문 체크
if (dp[r][c][dir] != -1) return dp[r][c][dir];

// 계산위해 초기화
dp[r][c][dir] = 0;
```

```java
dp[r][c][dir] += dfs(nr, nc, d); // 경로 누적
```
   
<br>

> 이상 까먹을 때쯤 매번 long형한테 당하는 리뷰였음...

---

## [백준 17144번 미세먼지 안녕!](https://www.acmicpc.net/problem/17144)

### 접근
- 문제 이해 -> 구현 문제 
- 미세먼지 확산이 **동시에** 일어난다를 이해하는게 중요했음
- map에서 순차대로 확산을 일으켜 누적된 결과로 다시 확산 실행이 아님
- 그렇기에 새로운 int[][] result를 만들어 값을 **누적**시키는 형태로 구현함

### 주의할 점
- 나름 백트래킹 한다고 확산할 양 `diffusion`이 없으면 넘어간다로 초기 코딩
- 그러나 이때 먼지의 양은 0이 아니기에 새로운 map인 `result`에 **값이 전달되지 않은 문제**가 발생!

#### 초기 문제

```java
if (map[r][c] <= 0) continue;
				
int count = 0; // 확산 횟수
int diffusion = map[r][c] / 5; // 확산되는 양

if (diffusion == 0) continue; // 이놈이 문제였음
```

#### 수정 후
```java
if (map[r][c] <= 0) continue;
				
int count = 0; // 확산 횟수
int diffusion = map[r][c] / 5; // 확산되는 양
```

### 풀이
- 문제에 주어진대로 확산(`diffuse`) -> 이동(`circulate`) 형태로 구현
- 이동 구현 시 delta를 사용하지 않고 4 방향에 대해 이동시킴 
- 이때 공기청정기 옆인 `map[upper][1] = 0`을 잊지 않게 주의해야 함.

```java
// 반시계 순환
for (int i = upper - 1; i > 0; i--)
    map[i][0] = map[i - 1][0];

for (int j = 0; j < C - 1; j++)
    map[0][j] = map[0][j + 1];

for (int i = 0; i < upper; i++) 
    map[i][C - 1] = map[i + 1][C - 1];
    
for (int j = C - 1; j > 1; j--)
    map[upper][j] = map[upper][j - 1];

map[upper][1] = 0;
```