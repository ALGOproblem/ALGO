# Week04 APS응용 과목평가

# 문제1_미술관의조명
## 문제 요약
### 1. N x N 사이즈의 미술관
검은 벽과 조명으로 구성
### 2. 조명
일직선 상하좌우 모든 방향 칸을 밝힘   
**조건: 벽 투과 불가능**

### 3. 답
벽을 제외하고 조명이 밝혀주고 있지 않은 칸의 수를 출력

## 문제 풀이
### 1. 접근 방식
- 상하좌우, 일직선이라는 방식으로 delta를 생각함
- `int[] dr`, `int[] dc`로 저장하여 밝히는 칸을 계산하자
    `static int[] dr = { 1, -1, 0, 0};`
	`static int[] dc = {0, 0, -1, 1};`   
### 2. 자료구조, 갱신 방식
- 미술관 정보 입력 -> `int[][] map` 배열에 저장
    - 0 : 빈칸
    - 1 : 벽
    - 2: 조명
   
- 동시에 조명 위치 `List<int[]> light`에 저장
    1. 조명의 위치를 저장
    2. 밝히는 곳(0)을 발견하면 미술관 정보 `map`의 값 갱신: 0 -> 2   
### 3. 탐색 방식
1. `List<int[]> light`의 값을 순서대로 선택
2. `turnOn`
3. `dr` `dc`를 for문을 통해 0-3까지 돌며 현재 위치 값을 변경
    - 벽/미술관 경계를 만나기 전까지 밝혀줌
    - 미술관 해당 위치 값이 0이면 2로 바꿔줌

---

# 문제2_룩과나이트
## 문제 요약
### 1. 기물
**룩, 나이트**라는 기물 2개만 존재
#### 룩 
- 상하좌우 한 방향으로 원하는 만큼 이동 가능
- 다른 기물 통과 불가능
#### 나이트
- 대각선 이동 후 수직/수평 방향으로 1칸 이동 가능
- 다른 기물에 막히지 않는다
#### 공통
- 이미 다른 기물이 놓인 위치로 이동 불가

### 2. 체스판
N x M 크기의 사각형 체스판<br>
룩, 나이트의 위치는 임의

### 3. 답
**K번 아무 기물이나 움직인 후** 룩, 나이트가 위치한 형태의 경우의 수 구하기<br>
**조건** : 이동순서(경로)가 달라도 최종 이동 후의 형태만 고려<br>
= 경로가 달라도 결과가 같으면 같은 결과로 본다


## 고전한 것들
### 1. 문제 자체에 대한 이해
1. 체스 규칙이 서로 오가며 기물을 두는 것이기에 누가 시작하더라도 다음 차례는 상대 기물이라고 오해함.
2. K번 기물 상관 없이 이동한다는 규칙을 이해하고도 문제 접근을 잘못함.

### 2. 문제 탐색 방식
1. 경로가 상관없다   
	- 룩, 나이트를 중복해서 선택하는 <ins>중복 순열</ins>을 떠올려야 했음
   
2. 이동방식   
	- 룩은 문제 1에 이동할 칸수를 정해야 한다.
	- delta 이동방향 -> 이동칸 수
	- 나이트는 이동 방식만 정하면 된다.   
   
3. 룩과 나이트는 서로 같은 곳에 존재할 수 없다. 그리고 룩은 나이트를 못 넘는다.   
   
4. 따라서 재귀보다 **bfs 탐색**이 유리하다.   
	- 이유: 내가 좋아하는 dfs, dikjstra는 모든 경우와 가중치 최단 경로 문제에 적합하다.
   	- dfs는 경로가 긴 경우에는 비효율적이며 백트래킹에 bfs보다 적합하지 않다.
   	- bfs : 최단 경로 탐색과 백트래킹으로 가지치기가 가능하다.
   	- 이 경우 3번 조건에 따라서 <ins>**룩, 나이트 이동 후 같은 칸에 위치할 수 없다**</ins>라는 조건만 확인하면 많은 경우의 수를 가지칠 수 있다.


### 3. 변수 선언 위치
- while문 카운트 변수, 정적변수 등을 선언하는 위치로 인해 무한 루프에서 빠져나오지 못했다.

## 문제 풀이 
### 변수
1. `int[][] map` : 체스판
2. 	`dr`, `dc`, `dk`: 각각 룩의 행, 열, 나이트의 delta
3. 	`Set<String> result` : 결과를 `룩의 행, 열, 나이트의 행, 열` 형태로 저장해 결과 중복 제거

### bfs
1. 큐 - 룩의 열, 행, 나이트의 행, 열, 이동횟수를 int[]에 저장
2. while: 기존 bfs 방식과 동일
3. **종료 조건: 이동횟수가 K일때 룩과 나이트의 위치가 달라야 결과에 저장한다**
4. 룩 이동 - (1) 델타방향 정하기 (2)이동할 수 있는 만큼 이동 (3) 큐에 이동횟수 + 1하여 삽입
5. 나이트 이동 - (2)를 제외하고 룩과 동일

### 결과
`result.size()`가 답이된다.

---

# 문제3_건물주고양이
